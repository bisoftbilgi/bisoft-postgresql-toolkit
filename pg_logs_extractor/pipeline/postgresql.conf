input {
  file {
    path              => ${PG_LOG_PATHS}
    start_position    => "beginning"
    sincedb_path      => "${SINCEDB_PATH}"
    discover_interval => 1
    stat_interval     => 0.5
    close_older       => 300
    ignore_older      => 0
  }
}

filter {
  if ![path] and [log][file][path] {
    mutate { replace => { "path" => "%{[log][file][path]}" } }
  }

  # server_id + filename from path (root independent)
  grok {
    match => { "path" => ".*/(?<server_id>[^/]+)/(?<filename>[^/]+)$" }
  }

  translate {
    field           => "server_id"
    destination     => "server_meta_json"
    dictionary_path => "/usr/share/logstash/extra/servers.yml"
    fallback        => "{\"cluster_name\":\"unknown\",\"server_name\":\"unknown\",\"server_ip\":\"0.0.0.0\"}"
  }

  json { source => "server_meta_json" target => "server_meta" }

  mutate {
    replace => {
      "cluster_name" => "%{[server_meta][cluster_name]}"
      "server_name"  => "%{[server_meta][server_name]}"
      "server_ip"    => "%{[server_meta][server_ip]}"
    }
    remove_field => ["server_meta_json","server_meta"]
  }
  # Drop ERROR and STATEMENT lines (noise)
  if [message] =~ /^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}\.\d+\s+\w+\s+\[\d+\]\s+user=.*\s+(ERROR|STATEMENT):/ {
    drop { }
  }

  # Parse main PostgreSQL log structure (UTC timezone format)
  grok {
    match => {
      "message" => [
        '^%{TIMESTAMP_ISO8601:log_time}\s+(?<tz>(?:[+-]\d{2}(?::?\d{2})?|UTC))\s+\[%{NUMBER:pid}\]\s+user=%{DATA:username},db=%{DATA:database_name}, client_ip=%{DATA:client_ip}\s+app=%{DATA:application_name}\s*(?:LOG|ERROR|FATAL|DETAIL|STATEMENT):\s+%{GREEDYDATA:pg_message}$'
      ]
    }
    tag_on_failure => ["_grokparsefailure"]
  }
  if [username] == "testuser" {
    drop { }
  }
  if [database_name] == "test" {
    drop { }
  }

  if [pg_message] =~ /application_name=/ {
    grok {
      match => {
        "pg_message" => 'application_name=%{GREEDYDATA:application_name}$'
      }
      overwrite => ["application_name"]
    }
    mutate {
      strip => ["application_name"]
    }
  }

  # Only process if main grok succeeded
  if "_grokparsefailure" not in [tags] {

    # Combine timestamp with timezone (UTC handling)
    if [tz] == "UTC" {
      mutate { add_field => { "log_time_full" => "%{log_time} +00:00" } }
    } else {
      mutate { add_field => { "log_time_full" => "%{log_time} %{tz}" } }
    }

    date {
      match  => ["log_time_full", "YYYY-MM-dd HH:mm:ss.SSS Z", "YYYY-MM-dd HH:mm:ss.SSS"]
      target => "log_time"
      timezone => "UTC"
    }

    # Route 1: Connection/Disconnection logs
    if [pg_message] =~ /^connection received:|^connection authorized:|^disconnection:/ {

      if [pg_message] =~ /^connection received:/ {
        mutate { add_field => { "action" => "connection_received" } }
      } else if [pg_message] =~ /^connection authorized:/ {
        mutate { add_field => { "action" => "connection" } }
      } else if [pg_message] =~ /^disconnection:/ {
        mutate { add_field => { "action" => "disconnection" } }
      }

      mutate {
        strip => ["username", "database_name", "client_ip", "action", "cluster_name", "server_name", "server_ip", "application_name"]
        remove_field => ["log_time_full", "tz", "pid", "pg_message", "@version", "host", "event", "log", "message"]
      }

      mutate { add_tag => ["connection_log"] }
    }
    else if [pg_message] =~ /password authentication failed/ {

      mutate { add_field => { "action" => "connection_failed" } }
      mutate {
        strip => ["username", "database_name", "client_ip", "action", "cluster_name", "server_name", "server_ip", "application_name"]
        remove_field => ["log_time_full", "tz", "pid", "pg_message", "@version", "host", "event", "log", "message"]
      }
      mutate { add_tag => ["connection_log"] }

    }
    # Route 2: Audit logs
    else if [pg_message] =~ /^AUDIT:/ {

      grok {
        match => {
          "pg_message" => "AUDIT:\s+SESSION,%{NUMBER:session_id},%{NUMBER:statement_id},%{WORD:audit_type},%{GREEDYDATA:statement_details}"
        }
      }

      grok {
        match => {
          "statement_details" => "(?<command>[^,]*),(?<object_type>[^,]*),(?<object_name>[^,]*),%{GREEDYDATA:statement_text}"
        }
        overwrite => ["command", "object_type", "object_name", "statement_text"]
      }

      mutate {
        gsub => [
          "statement_text", ",<not logged>", "",
          "statement_text", "^\"|\"$", ""
        ]
        strip => ["statement_text", "database_name"]
      }

      if [object_type] == "," or [object_type] == "" {
        mutate { replace => { "object_type" => "" } }
      }
      if [object_name] == "," or [object_name] == "" {
        mutate { replace => { "object_name" => "" } }
      }

      mutate {
        strip => ["username", "session_id", "statement_id", "audit_type", "statement_text", "command", "object_type", "object_name", "cluster_name", "server_name", "server_ip", "client_ip", "application_name"]
        remove_field => ["statement_details", "tz", "pid", "pg_message", "log_time_full", "@version", "host", "event", "log", "message"]
      }

      mutate { add_tag => ["audit_log"] }
    }

    else {
      drop { }
    }
  } else {
    drop { }
  }
}

output {
  if "connection_log" in [tags] {
    jdbc {
      connection_string => "jdbc:postgresql://${PG_HOST}:${PG_PORT}/${PG_DB}"
      driver_class      => "org.postgresql.Driver"
      driver_jar_path   => "${JDBC_JAR}"
      username          => "${PG_USER}"
      password          => "${PG_PASS}"
      statement => [
        "INSERT INTO connection_logs (log_time, username, database_name, client_ip, action, cluster_name, server_name, server_ip, application_name) VALUES (?::timestamptz, ?, ?, ?, ?, ?, ?, ?, ?)",
        "log_time","username","database_name","client_ip","action","cluster_name","server_name","server_ip","application_name"
      ]
      flush_size => 1
      max_pool_size => 5
    }
  }

  if "audit_log" in [tags] {
    jdbc {
      connection_string => "jdbc:postgresql://${PG_HOST}:${PG_PORT}/${PG_DB}"
      driver_class      => "org.postgresql.Driver"
      driver_jar_path   => "${JDBC_JAR}"
      username          => "${PG_USER}"
      password          => "${PG_PASS}"
      statement => [
        "INSERT INTO audit_logs (log_time, username, database_name, session_id, statement_id, audit_type, statement_text, command, object_type, object_name, cluster_name, server_name, server_ip, client_ip, application_name) VALUES (?::timestamptz, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
        "log_time","username","database_name","session_id","statement_id","audit_type","statement_text","command","object_type","object_name","cluster_name","server_name","server_ip","client_ip","application_name"
      ]
      flush_size => 1
      max_pool_size => 5
    }
  }
  stdout { codec => rubydebug }
}

